<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome!</title>
    <link>https://paschermayr.github.io/</link>
      <atom:link href="https://paschermayr.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>Welcome!</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Fri, 02 Oct 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://paschermayr.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Welcome!</title>
      <link>https://paschermayr.github.io/</link>
    </image>
    
    <item>
      <title>Bayesian Inference in State Space Models - Part 1</title>
      <link>https://paschermayr.github.io/post/statespacemodels-3-inference-in-state-space-models-part-1/</link>
      <pubDate>Fri, 02 Oct 2020 00:00:00 +0000</pubDate>
      <guid>https://paschermayr.github.io/post/statespacemodels-3-inference-in-state-space-models-part-1/</guid>
      <description>&lt;p&gt;Inference in State Space Models - an Overview&lt;/p&gt;
&lt;h1 id=&#34;hi-there&#34;&gt;Hi there!&lt;/h1&gt;
&lt;p&gt;In my previous posts, I introduced two discrete state space model (SSM) variants: the

&lt;a href=&#34;https://paschermayr.github.io/post/statespacemodels-1-a-primer-on-state-space-models/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;hidden Markov model&lt;/a&gt; and

&lt;a href=&#34;https://paschermayr.github.io/post/statespacemodels-2-hsmm/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;hidden semi-Markov model&lt;/a&gt;. However, in all code examples,
model parameter were already given - what happens if we need to estimate them? This post is the first of a series of four blog entries, in which I will explain a general framework to perform parameter
inference on SSMs and implement a basic example for demonstration. Ideally, I would make all three posts as applied as my previous articles, but I have to use some theory in the
beginning to make things easier going forward.&lt;/p&gt;
&lt;p&gt;While SSMs are very flexible and can describe data with a complex structure, parameter estimation can be very challenging.
Analytical forms of the corresponding likelihood functions are only available in special cases
and, thus, standard parameter optimization routines might be unfeasible. Consequently, the major challenge in solving SSMs is the generally intractable
likelihood function $p_{\theta}(e_{1:t}) = \int p_{\theta}(e_{1:t}, s_{1:t}) d s_{1:t}$, which integrates over the (unknown) latent state trajectory. As previously mentioned,
$E_t$ is the observed data and $S_t$ the corresponding latent state.&lt;/p&gt;
&lt;h1 id=&#34;so-what-can-we-do&#34;&gt;So what can we do?&lt;/h1&gt;
&lt;p&gt;If both $E_t$ and $S_t$ follow a Normal distribution, one may analytically estimate the corresponding model parameter via the so called Kalman equations,
but given these very specific assumptions, we will not concentrate on this special case going forward.
If $S_{1:T}$ is discrete, then the most common point estimation technique is the EM-Algorithm.
In this case, one can use common filtering techniques, explained in (Rabiner, 1989), to iteratively calculate state probabilities and update model parameter.
Once the EM-Algorithm has reached some convergence criterion, one may estimate the most likely state trajectory given the estimated parameter. I will not go into
much detail here because this procedure has been explained on many occasions and will instead refer to the literature above.
However, both approaches do not work in many cases. The former technique only works with very specific model assumptions.
The latter technique is not available in case $S_{1:T}$ is continuous. Moreover, even if the state sequence is
discrete, summing out the state space might be computationally very challenging if the latent state structure is complex. In addition, one may not be able to
write down the analytical forms of the updating equations for more complex state space models.&lt;/p&gt;
&lt;p&gt;Another popular approach is to use Gibbs sampling, where one uses the previously mentioned filtering techniques to obtain a sample from the
whole state trajectory $S_{1:T}$, and then sample model parameter conditional on this path.
This technique suffers from the usually high autocorrelation within the model parameter vector and the state sequence.
Moreover, ideally one would like to perform estimation jointly for the model parameter $\theta$ and the latent state space $S_{1:T}$, as both have a high interdependence as well. This is not feasible for either method that I mentioned so far.
For a more in-depth discussion, an excellent comparison of point estimation and Bayesian techniques is given by (Ryden, 2008).&lt;/p&gt;
&lt;h1 id=&#34;a-general-framework-to-perform-inference-on-state-space-models&#34;&gt;A general framework to perform inference on state space models&lt;/h1&gt;
&lt;p&gt;Given the statements above, I will now focus on a general approach to perform joint estimation on the model parameter and state trajectory of state space models,
independent of the variate form of the latent space and the distributional assumptions on the observed variables. This is, to the best of my
knowledge, only possible in a Bayesian setting, where we target the full joint posterior $P( s_{1:T}, \theta \mid e_{1:T})$ by iterating over the following steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;propose $\theta^{\star} \sim f(\theta^{\star} \mid \theta)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;propose $S^\star_{1:T} \sim P(s^{\star}_{1:T} \mid \theta^{\star}, e_{1:T})$.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;and then accept this pair $(\theta^{\star}, s^{\star}_{1:T})$ with acceptance probability&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!---	$ \frac{P(E \mid \theta^{\star})}{P(E \mid \theta)} \frac{P(\theta^{\star})}{P(\theta)} \frac{q(\theta \mid \theta^{\star})}{q(\theta^{\star} \mid \theta)}$  --&gt;
&lt;p&gt;$$
\begin{equation}
\begin{split}
A_{PMCMC} &amp;amp;= \frac{ P( s^{\star}_{1:T} \mid \theta^{\star}) }{  P(s_{1:T} \mid \theta ) }
\frac{ P(e_{1:T} \mid s^{\star}_{1:T}, \theta^{\star}) }{  P(e_{1:T} \mid s_{1:T}, \theta ) }
\frac{ P(s_{1:T} \mid e_{1:T}, \theta) }{  P(s^{\star}_{1:T} \mid e_{1:T}, \theta^{\star}) }
\frac{P(\theta^{\star})}{P(\theta)} \frac{q(\theta \mid \theta^{\star})}{q(\theta^{\star} \mid \theta)} \\&lt;br&gt;
&amp;amp;= \frac{P(e_{1:T} \mid \theta^{\star})}{P(e_{1:T} \mid \theta)} \frac{P(\theta^{\star})}{P(\theta)} \frac{q(\theta \mid \theta^{\star})}{q(\theta^{\star} \mid \theta)}. \&lt;br&gt;
\end{split}
\end{equation}
$$&lt;/p&gt;
&lt;p&gt;Okay, but what does that even mean? In the first step, we propose a new parameter vector $\theta^{\star}$ from a MCMC proposal distribution. I will not go over the basics
of MCMC, as this has been explained in many other articles, but we will implement an example in part 3 of this tutorial. Given this $\theta^{\star}$, we sample a new trajectory
$s^\star_{1:T}$ and jointly accept this pair with the acceptance ratio from point 3. This framework allows to jointly sample $\theta$ and $S_{1:T}$, which was our goal in the first place.
However, the in general intractable likelihood term is still contained in the acceptance probability in step 3,
which is simplified by using the basic marginal likelihood identity (BMI) from (Chib, 1995).
Consequently, the difficulty to obtain a sample from the posterior remains the same: we need to evaluate the (marginal) likelihood of the model.&lt;/p&gt;
&lt;h1 id=&#34;the-particle-mcmc-idea&#34;&gt;The Particle MCMC idea&lt;/h1&gt;
&lt;p&gt;An alternative is to replace this (marginal) likelihood with an unbiased estimate $\hat{ \mathcal{L} }$$_\theta(e_{1:T})$. In this setting, (Andrieu and Roberts, 2010) have shown the puzzling result that one
can do so and still target the exact posterior distribution of interest, thereby opening a completely new research area now called &amp;lsquo;exact approximate MCMC&amp;rsquo;.
The algorithm that is used in this setting targets the full posterior and is known as Particle MCMC (PMCMC).
Here, a particle filter (PF) is used to obtain a sample for $S_{1:T}$. A by-product of this procedure is that we also obtain an unbiased estimate for the likelihood.
If you are more interested in PFs, have a look at the paper from (Doucet, A. and Johansen, 2011).
For anyone wondering: as $p(s_{1:T} \mid e_{1:T}, \theta )$ is replaced with an approximation $\hat{p}(s_{1:T} \mid e_{1:T}, \theta )$,
the approximation does not admit $p(s_{1:T}, \theta \mid e_{1:T})$ as invariant density, but
this is corrected in the PMCMC algorithm via step 3.&lt;/p&gt;
&lt;h1 id=&#34;going-forward&#34;&gt;Going forward&lt;/h1&gt;
&lt;p&gt;The PMCMC machinery provides a very powerful framework and cures many of the difficulties in the estimation paradigms mentioned at the
beginning of this series. In reality, however, much of the performance depends on whether you find a good proposal
distribution $ f( . \mid \theta)$ and $P(s^\star_{1:T} \mid \theta^{\star}, e_{1:T})$.
Moreover, we have yet not mentioned how this machinery scales in the dimension of $\theta$ and $S_{1:T}$.
These are all questions that I pursue in my own PhD studies, and we may venture through them once we know the very basics.&lt;/p&gt;
&lt;p&gt;In the next blog post, we will implement a particle filter to do inference on the latent state trajectory. Going forward, we then talk about doing MCMC in this case,
and implement a basic framework to sample from an unconstrained parameter space. Last but not least, we will combine all of this and apply a PMCMC
algorithm on a standard HMM to obtain parameter estimates.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;p&gt;Andrieu, C. and Roberts, G. O. (2010). The pseudo-marginal approach for efficient monte carlo computations.
Ann. Statist., 37(2):697-725.&lt;/p&gt;
&lt;p&gt;Chib, S. (1995). Marginal likelihood from the gibbs output. Journal of the American Statistical Association,
90(432):1313-1321.&lt;/p&gt;
&lt;p&gt;Doucet, A. and Johansen, A. (2011). A tutorial on particle filtering and smoothing: Fifteen years later.&lt;/p&gt;
&lt;p&gt;Rabiner, L. R. (1989). A tutorial on hidden markov models and selected applications in speech recognition.
Proceedings of the IEEE, 77(2):257-286.&lt;/p&gt;
&lt;p&gt;Ryden, T. (2008). Em versus markov chain monte carlo for estimation of hidden markov models: A computational
perspective. Bayesian Analysis, 3(4):659-688.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>State Space Models Everywhere! Round 1: HSMM</title>
      <link>https://paschermayr.github.io/post/statespacemodels-2-hsmm/</link>
      <pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://paschermayr.github.io/post/statespacemodels-2-hsmm/</guid>
      <description>&lt;p&gt;Introducing Hidden semi-Markov Models&lt;/p&gt;
&lt;h1 id=&#34;hi-there&#34;&gt;Hi there!&lt;/h1&gt;
&lt;p&gt;In the 
&lt;a href=&#34;https://paschermayr.github.io/post/statespacemodels-1-a-primer-on-state-space-models/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;last article&lt;/a&gt;, you got a first impression about state space models and, as an example,
the basic hidden Markov model:
&lt;img src=&#34;https://paschermayr.github.io/files/post/BayesianHMM.png&#34; alt=&#34;A plot&#34;&gt;&lt;/p&gt;
&lt;p&gt;We already talked about various advantages of state space models, but - depending on the features of the underlying data that you want to model -
basic HMMs just might not be good enough. Here is why:&lt;/p&gt;
&lt;h1 id=&#34;a-geometric-duration-distribution-is-a-problem&#34;&gt;A geometric duration distribution is a problem&lt;/h1&gt;
&lt;p&gt;Let us focus on the unobserved process, $S_t$, for now. We are interested in the actual time
spent in a particular state. Let us calculate the probability  that we are currently
in state $i$ and remain here for the next two time steps. For a discrete 2-state, homogenous Markov chain, using the chain rule and the Markov assumption of the basic model, we can write:
$$
\begin{equation}
\begin{split}
P( S_{t+3} = j, S_{t+2} = i, S_{t+1} = i \mid S_{t} = i ) &amp;amp;= P( S_{t+3} = j\mid S_{t+2} = i) P(S_{t+2} = i,  \mid S_{t+1} = i) P( S_{t+1} = i \mid S_{t} = i ) \\&lt;br&gt;
&amp;amp;= (1 - \tau_{ii}) * \tau_{ii}^2
\end{split}
\label{eq:HMM_geom1}
\end{equation}
$$&lt;/p&gt;
&lt;p&gt;In general, for $t+k$ steps:
$$
\begin{equation}
\begin{split}
P( S_{t+k} = j, \dots, S_{t+1} = i \mid S_{t} = i ) &amp;amp;= (1 - \tau_{ii}) * \tau_{ii}^{k-1} \\&lt;br&gt;
&amp;amp;= Geometric_{ \tau_{ii} },
\end{split}
\label{eq:HMM_geom2}
\end{equation}
$$
where the geometric distribution has to be interpreted as the length of state duration up to and including the transition to the other state.
Why is this a problem?
The hidden states you model may switch more rapidly than you would like them to
do. Even if you assign parameter very close to the boundaries of its support, the duration distribution will always implicitly be geometric.
That makes it unsuitable if you want to model something that is supposed to stay in a particular state for a long time. As an example, let us say you want to model economic cycles
of a developed country. You typically expect an expansion to last on average 5-10 years, but modelling such long durations is unfeasable with daily input data for an HMM. To circumvent this issue, one may
use weekly or monthly data, but why give up data and essential information if alternatives are available?&lt;/p&gt;
&lt;h1 id=&#34;from-hmms-to-hsmms&#34;&gt;From HMMs to HSMMs&lt;/h1&gt;
&lt;p&gt;As a solution, we can model these state duration probabilities explicitly. Such models are known as hidden semi-Markov models (HSMM), and they are a powerful
generalization of the basic HMM. HSMMs have an additional latent variable, lets call it $D_t$ for duration that
determines how long one may stay in any given state. $S_t$ will only have the Markov property while transitioning,
otherwise it is determined by $D_t$. The tuple $\{ S_t, D_t \}$ forms a so-called semi-Markov chain.
Let us visualize this:
&lt;img src=&#34;https://paschermayr.github.io/files/post/BayesianHSMM.png&#34; alt=&#34;A plot&#34;&gt;&lt;/p&gt;
&lt;p&gt;In an HSMM, transitions are allowed only at the end of each state, resulting in the following distributional forms:&lt;/p&gt;
&lt;p&gt;$$
\begin{equation}
S_t \mid s_{t-1}, d_{t-1} \sim P( S_t \mid s_{t-1}, d_{t-1} ) = \begin{cases}
\delta( S_{t} = s_{t-1}) &amp;amp;\text{ $d_{t-1} &amp;gt; 0$ }\\&lt;br&gt;
\mathcal{T}_{s_{t-1},.} &amp;amp;\text{ $d_{t-1} = 0$ }
\end{cases}
\label{eq:EDHMM_transition}
\end{equation}
$$&lt;/p&gt;
&lt;p&gt;$$
\begin{equation}
D_t \mid s_{t}, d_{t-1} \sim P(D_t \mid s_{t}, d_{t-1}) = \begin{cases}
\delta( D_{t} = d_{t-1} - 1) &amp;amp;\text{ $d_{t-1} &amp;gt; 0$ } \\&lt;br&gt;
\mathcal{D}_{s_{t}} &amp;amp;\text{ $d_{t-1} = 0$ }
\end{cases}
\label{eq:EDHMM_duration}
\end{equation}
$$&lt;/p&gt;
&lt;p&gt;$$
\begin{equation}
E_t \mid s_{t} \sim \mathcal{O}_{s_{t}}
\label{eq:EDHMM_observation}
\end{equation}
$$&lt;/p&gt;
&lt;p&gt;where $\delta(a,b)$ is the Kronecker product and equals $1$ if $a = b$ and $0$ otherwise.&lt;/p&gt;
&lt;p&gt;Note that, as we model the duration explicitly now, we have to slightly adjust the
transition matrix that we used in the 
&lt;a href=&#34;https://paschermayr.github.io/post/statespacemodels-1-a-primer-on-state-space-models/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;previous article&lt;/a&gt;. The diagonal elements of the transition matrix - the probability to remain in any given state in the next time step,
which formally is depicted as $\tau_{i,i} = P(s_{t+1} = i \mid s_{t} = i)$ - are now set to 0. The rest of the row elements in the transition matrix still need to sum up to 1. If you have trouble
understanding that, check out the code below.&lt;/p&gt;
&lt;h1 id=&#34;let-us-code&#34;&gt;Let us code!&lt;/h1&gt;
&lt;p&gt;To understand the code for sampling a single trajectory of said HSMM more clearly, keep reading:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The function input are the model distributions stated above.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The function output is a single trajectory of the observed and latent variables.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Before we start the for-loop over time, we need to define the initial state. If the latent states of the data are conceived as a subsequence of a
long-running process, the probability of the initial state should be set to the stationary state probabilities
of this unobserved Markov chain. This plays an important part in the estimation paradigm, but for now we simply choose any
of the available states with equal probability. Don&amp;rsquo;t worry if this sounds difficult - we will come back to it in a later article.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The for-loop samples the new state given the old state, and then the observation given the new state, over time. The corresponding distributions
are stated above.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the HSMM case, we check if the duration in the previous time step reached 0. If true, we sample a new state and duration given this state. If not,
the current state continues, and we decrease the duration count by 1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;That&amp;rsquo;s it! Let us have a look:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;
using Distributions

function sampleHSMM(evidence::Vector{&amp;lt;:Distribution}, duration::Vector{&amp;lt;:Distribution}, transition::Matrix{Float64}, T::Int64)
        #Initialize states and observations
        state = zeros(Int64, T)
        state_length = zeros(Int64, T)
        observation = zeros(Float64, T)

        #Sample initial s from initial distribution
        state[1] = rand( 1:size(transition, 1) ) #not further discussed here
        state_length[1] = rand( duration[ state[1] ] ) #not further discussed here
        observation[1] = rand( evidence[ state[1] ] )

        #Loop over Time Index
        for time in 2:T
                if state_length[time-1] &amp;gt; 0
                        state[time] = state[time-1]
                        state_length[time] = state_length[time-1] - 1
                        observation[time] = rand( evidence[ state[time] ] )
                else
                        state[time] = rand( Categorical( transition[ state[time-1], :] ) )
                        state_length[time] = rand( duration[ state[time] ] )
                        observation[time] = rand( evidence[ state[time] ] )
                end
        end
        #Return output
        return state, state_length, observation
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;sampleHSMM (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let us generate one sample path of said model. I am still using normal observation distributions, but added a third state  so you can have a visual example from the transition matrix adjustment talk above.
I will use a Negative Binomial distribution to model the state duration, but you are free to choose whatever you like best as long as the support lies on the non-negative Integers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;
using Plots

T = 5000
evidence =  [Normal(0., .5), Normal(0.,1.), Normal(0.,2.)]
duration =  [NegativeBinomial(100., .2), NegativeBinomial(10., .05), NegativeBinomial(50.,0.5)]
transition = [0.0 0.5 0.5;
              0.8 0.0 0.2;
              0.8 0.2 0.0;]
state, state_length, observation = sampleHSMM(evidence, duration, transition, T)

plot( layout=(3,1), label=false, margin=-2Plots.px)
plot!(observation, ylabel=&amp;quot;data&amp;quot;, label=false, subplot=1, color=&amp;quot;gold4&amp;quot;)
plot!(state, yticks = (1:3), ylabel=&amp;quot;state&amp;quot;, label=false, subplot=2, color=&amp;quot;black&amp;quot;)
plot!(state_length, ylabel=&amp;quot;duration&amp;quot;, label=false, subplot=3, color=&amp;quot;blue&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;















&lt;figure &gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://paschermayr.github.io/files/post/2%20HSMM_2_1.png&#34; &gt;


  &lt;img src=&#34;https://paschermayr.github.io/files/post/2%20HSMM_2_1.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;To see why the HSMM is a large improvement over the previous model, try to mimic the average state duration with the code that we used for the

&lt;a href=&#34;https://paschermayr.github.io/post/statespacemodels-1-a-primer-on-state-space-models/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;basic HMM model&lt;/a&gt;. Likewise, you can choose a geometric state duration in the example here to mimic the HMM case. While the latter is done easily,
the former should almost be unfeasable. As always, you can download the full script from my 
&lt;a href=&#34;https://github.com/paschermayr/Shared-Code&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub account&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;thats-it-for-today&#34;&gt;That&amp;rsquo;s it for today!&lt;/h1&gt;
&lt;p&gt;Well done! Initially, I wanted to write an article about several model extensions, but I quickly figured that this would be much
too long for what I was planning to do, and therefore focused on HSMMs only in this post.
I am going to gradually write follow-up posts on this one, as there exist many more state space models with an interesting structure, such as autoregressive or factorial HMMs.
See you soon!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Primer on State Space Models</title>
      <link>https://paschermayr.github.io/post/statespacemodels-1-a-primer-on-state-space-models/</link>
      <pubDate>Sun, 06 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://paschermayr.github.io/post/statespacemodels-1-a-primer-on-state-space-models/</guid>
      <description>&lt;p&gt;Introducing State Space Models&lt;/p&gt;
&lt;h1 id=&#34;welcome&#34;&gt;Welcome!&lt;/h1&gt;
&lt;p&gt;In my first series of posts, I will give a primer on state space models (SSM) that will lay a foundation in
understanding upcoming posts about their variants, usefulness, methods to apply inference and forecasting possibilities.
When talking about a state space model (SSM), people usually refer to a bivariate stochastic process $\{ E_t, S_t \}_{t = 1,2,\ldots ,T }$, where $S_t$ is an unobserved
Markov chain and $E_t$ is an observed sequence of random variables. This may sounds difficult now, so let us look at a graphical example of one of the
most well known SSMs out there - the so called Hidden Markov Model (HMM):
&lt;img src=&#34;https://paschermayr.github.io/files/post/BayesianHMM.png&#34; alt=&#34;A plot&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;so-what-are-ssms-really&#34;&gt;So, what are SSMs really?&lt;/h1&gt;
&lt;p&gt;Cool! To sum up the idea above in words, there is some unobserved process $S_t$ guiding the underlying data $E_t$. The Greek letters in the square
box are the corresponding model parameter, which we assume to be fixed for now, and their priors. For example, maybe you own some shares of a company? Then the periodic changes in
your portfolio, $e_t$, will be influenced by the current state of the economy, $s_t$. Hence, you may model this relationship as an HMM.
There are many different variants of the model stated above, which I will discuss in future posts. One may include some autoregressive structure for the observation sequence,
or one may decide to model the state sequence as a higher order Markov chain or even as a semi-Markov chain. Depending on the underlying data you want to model, one may also
want to combine several of these ideas.&lt;/p&gt;
&lt;h1 id=&#34;and-why-are-they-useful&#34;&gt;And why are they useful?&lt;/h1&gt;
&lt;p&gt;It turns out that having an underlying, unobserved process guiding some observed variables is a phenomenon that comes up naturally in many different areas.
While I used an example from finance, there are many areas in genetics, anomaly detection and speech and pattern recognition, among others,
where this structure comes up naturally and SSM can be applied successfully. Moreover, these models&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;can handle structural breaks, shifts, or time-varying parameters of a model. Model parameter will adjust depending on the current state.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;allow you to model complex and nonlinear relationships.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;handle missing and irregular spaced data easily.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;can be used to do forecasting naturally due to their sequential setting.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have interpretable structure to perform inference.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So even if someone is only interested in the observed sequence, the addition of a latent variable offers much additional flexibility that
might not be feasable otherwise. This comes at the price that SSMs are, in general, computationally hard to estimate. I will go further into this topic in a separate post.&lt;/p&gt;
&lt;h1 id=&#34;sampling-our-very-first-state-space-model&#34;&gt;Sampling our very first State Space Model&lt;/h1&gt;
&lt;p&gt;For our first SMM, we will use observations that are normally distributed given the states. In this case, $S_t$ is a first order Markov chain, which can be depicted as a
so called transition matrix $\tau$ . Each row in this matrix has a Categorical distribution, and the parameters thus have to sum up to 1 and are bounded between 0 and 1.
$$
\begin{equation}
\begin{split}
&amp;amp; e_t \sim  Normal(\mu_{s_t}, \sigma_{s_t} ) \\&lt;br&gt;
&amp;amp; s_t \sim  Categorical( \tau_{s_{t-1}}) \&lt;br&gt;
\end{split}
\end{equation}
$$
Let&amp;rsquo;s write down a function that can generate sample paths of the HMM from above. I will mainly use Julia in my blog posts, as this programming language is incredibly fast
and readable, and has some amazing features to make the life of anyone doing scientific computational research much easier. Here are some notes to help
understand the code to sample a single trajectory of said HMM:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The function input are the model distributions stated above.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The function output is a single trajectory of the observed and latent variables.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Before we start the for loop over time, we need to define the initial state. If the latent states of the data are conceived as a subsequence of a
long-running process, the probability of the initial state should be set to the stationary state probabilities
of this unobserved Markov chain. This plays an important part in the estimation paradigm, but for now we simply choose any
of the available states with equal probability. Don&amp;rsquo;t worry if this sounds difficult for you - we will come back to it in a future post.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The for loop samples the new state given the old state, and then the observation given the new state, over time. The corresponding distributions
are stated above.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;That&amp;rsquo;s it! Let us have a look:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;
using Plots, Distributions

function sampleHMM(evidence::Vector{&amp;lt;:Distribution}, transition::Vector{&amp;lt;:Distribution}, T::Int64)
        #Initialize states and observations
        state = zeros(Int64, T)
        observation = zeros(Float64, T)

        #Sample initial s from initial distribution
        state[1] = rand( 1:length(transition) ) #not further discussed here
        observation[1] = rand( evidence[ state[1] ] )

        #Loop over Time Index
        for time in 2:T
                state[time] = rand( transition[ state[time-1] ] )
                observation[time] = rand( evidence[ state[time] ] )
        end
        return state, observation
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;sampleHMM (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To round out this post, you can check out this function with different distributions and transition matrices:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;
T = 100
evidence =  [Normal(0., .5), Normal(0.,2.)]
transition = [ Categorical([0.7, 0.3]), Categorical([0.5, 0.5]) ]

state, observation = sampleHMM(evidence, transition, T)

plot( layout=(2,1), label=false, margin=-2Plots.px)
plot!(observation, ylabel=&amp;quot;data&amp;quot;, label=false, subplot=1, color=&amp;quot;gold4&amp;quot;)
plot!(state, yticks = (1:2), ylabel=&amp;quot;state&amp;quot;, xlabel=&amp;quot;time&amp;quot;, label=false, subplot=2, color=&amp;quot;black&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;















&lt;figure &gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://paschermayr.github.io/files/post/1%20A%20primer%20on%20State%20Space%20Models_2_1.png&#34; &gt;


  &lt;img src=&#34;https://paschermayr.github.io/files/post/1%20A%20primer%20on%20State%20Space%20Models_2_1.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;You can download the full script from my 
&lt;a href=&#34;https://github.com/paschermayr/Shared-Code&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub account&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;going-forward&#34;&gt;Going forward&lt;/h1&gt;
&lt;p&gt;We are off to a good start! Next time we will have a closer look at different variants of state space models and their subtle differences.
This should give you a better understanding of possible use cases for SSMs!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Research Update Presentation</title>
      <link>https://paschermayr.github.io/talk/lse-2020-phd-research-update/</link>
      <pubDate>Fri, 01 May 2020 13:00:00 +0000</pubDate>
      <guid>https://paschermayr.github.io/talk/lse-2020-phd-research-update/</guid>
      <description>&lt;p&gt;Slides will be added at a later date.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Research Poster Presentation</title>
      <link>https://paschermayr.github.io/talk/lse-2019-seds/</link>
      <pubDate>Mon, 20 May 2019 13:00:00 +0000</pubDate>
      <guid>https://paschermayr.github.io/talk/lse-2019-seds/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Research Update Presentation</title>
      <link>https://paschermayr.github.io/talk/lse-2019-phd-research-update/</link>
      <pubDate>Wed, 01 May 2019 13:00:00 +0000</pubDate>
      <guid>https://paschermayr.github.io/talk/lse-2019-phd-research-update/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
